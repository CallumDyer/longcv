# Very Early Computing Experiences

In 1984, when I was 4 years old, my dad bought a ZX Spectrum - the British counterpart to the C64 that was popular in the US.
He showed me how to write simple for loops in BASIC to draw concentric circles in different colours on the screen, which is
one of my earliest memories. I have a distinct recollection of him explaining the syntax for defining a function to me
and me not understanding what a function was.

There was then a gap of a few years but I recall only playing games on the Spectrum at around age 7 or 8, just before he sold
it and bought a PC clone powered by an 8086 CPU with a pair of 5 1/4 inch floppy disks for storage - one had to hold the OS
while the other held the application!
Around age 9 or so I was bored and decided to read through the entire DOS manual and try out all the commands on the PC.
While not technically programming, that was the beginning of me using computers to do someting other than just play games.

That said, I did accidentally learn one very key computing concept by playing a game. It was a silly game where you had to
guess a randomly selected number between 1 and 100. I quickly realized that the most reliably efficient way to guess the
number was by using binary search, although I didn't realize until many years later that this process had a name.

# K-12 Education

In grade 7 we had a class where we learned how to use LOGO to draw on the screen. LOGO remains my ideal choice for
introducing programming to kids because it's very simple to get started and you see immediate visual results but it is a real
programming language with precise syntax (as opposed to a visual one like Scratch).

In either grade 9 or 10 I took another class where we learned GW BASIC and I finally understood what my dad had been trying 
to explain about defining functions. 

After that I took a class in grade 11 where we learned a neat little language called Turing that had a clean syntax but could
be compiled into a binary executable. Turing is where I really learned about complex branching/selection via nested if
statements.
The next year I learned some basic C and had mild exposure to a few other things (C++, Java, Javascript). By this point I was 
pretty sold on the notion of programming as a career but didn't yet grasp the concept of memory indirection via pointers.

# College

My first couple of programming classes at the University of Waterloo were in Java, which I initially liked, and Scheme
(a Lisp dialect), which I did not. It was through Java that I learned how to use recursion and objects.
In my sophomore year we learned C++ and thereafter we had the choice of those two very mainstream languages for most 
assignments, although a few classes (e.g. OS, concurrency, distributed systems) required C++.
In my final year I also dabbled in Python a bit and had mild exposure to a few more esoteric languages (e.g. ML, Haskell).
Despite this, I still hadn't grokked functional programming!

# Industry

After spending my first year on the job using Java, I switched to C++ for the next couple of years and then to C for a year.
Then I quit my job and dabbled in using Python to build an AppEngine server, Javascript to build an HTML5 web app and Java to
build an Android app.
I got another job where I used both C and Python for a few months and then another job where I learned Scala, which I loved.
Scala is what finally got me to wrap my head around functional programming.

Five years ago I started my current job, where I used mostly C++ with a bit of Python and Java for the first two years and
since then it's been mostly Go with a bit of Javascript to build infrastructure and web front-ends. Go has cured me of the
need to use inheritence for code reuse.
